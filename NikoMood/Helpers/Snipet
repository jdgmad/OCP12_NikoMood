    var dictionary = ["a": ["aberration", "abc"], "b" : ["babel", "bereft"]]
    var searchText = "aberration"
    var filteredDictionary = dictionary.filter { (key, value) -> Bool in
            return (value as! [String]).contains(searchText)
        }.mapValues { (values) -> [String] in
            return [searchText]
        }
    print(filteredDictionary)
    
    <<<<<<<<<<<<<<<<<<<
    
    override func prepareForReuse() {
    super.prepareForReuse()

    imageView.image = //Default image
    //Whatever other things you need cleared.
}

    <<<<<<<<<<<<<<<<<<<<<<<<<
 
 struct Favourite: Codable, Identifiable {
  var itemActive: Bool
  var itemAdded: Date
}

struct UserPreference: Codable, Identifiable {
  @DocumentID public var id: String?
  var displayName: String
  var email: String
  var favourites: [Favourite]?
}
 
public class UserPreferenceRepository: ObservableObject {
  var db = Firestore.fireStore()
  @Published var userPreferences = [UserPreference]()
  private var listenerRegistration: ListenerRegistration?

  public func subscribe() {
    if listenerRegistration == nil {
      
      var query = db.collection("users")
      
      listenerRegistration =
        query.addSnapshotListener { [weak self] (querySnapshot, error) in
          guard let documents = querySnapshot?.documents else {
            self?.logger.debug("No documents")
            return
          }
          
          self?.userPreferences = documents.compactMap { queryDocumentSnapshot in
            try? queryDocumentSnapshot.data(as: UserPreference.self)
          }
        }
    }
  }
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

Regroupement des valeurs de tableau
Si nous avons une structure comme celle-ci

struct Box {
    let name: String
    let thingsInside: Int
}
et un tableau de Box(es)

let boxes = [
    Box(name: "Box 0", thingsInside: 1),
    Box(name: "Box 1", thingsInside: 2),
    Box(name: "Box 2", thingsInside: 3),
    Box(name: "Box 3", thingsInside: 1),
    Box(name: "Box 4", thingsInside: 2),
    Box(name: "Box 5", thingsInside: 3),
    Box(name: "Box 6", thingsInside: 1)
]
nous pouvons regrouper les boîtes par la propriété thingsInside pour obtenir un Dictionary où la key est le nombre de choses et la valeur un tableau de boîtes.

let grouped = boxes.reduce([Int:[Box]]()) { (res, box) -> [Int:[Box]] in
    var res = res
    res[box.thingsInside] = (res[box.thingsInside] ?? []) + [box]
    return res
}
Maintenant regroupé est un [Int:[Box]] et a le contenu suivant

[
    2: [Box(name: "Box 1", thingsInside: 2), Box(name: "Box 4", thingsInside: 2)],
    3: [Box(name: "Box 2", thingsInside: 3), Box(name: "Box 5", thingsInside: 3)],
    1: [Box(name: "Box 0", thingsInside: 1), Box(name: "Box 3", thingsInside: 1), Box(name: "Box 6", thingsInside: 1)]
]

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
var i = dict.startIndex

while i < dict.endIndex {
  let (key, value) = dict[i]
  dict.updateValue(/*...*/, forKey: key)
  dict.formIndex(after: &i)
}

<<<<<<<<<<<<<<<<<<<<<<<<<<<
let currentDate = Date()
var dateComponent = DateComponents()
dateComponent.day = 1
let futureDate = Calendar.current.date(byAdding: dateComponent, to: currentDate)
print(currentDate)
print(futureDate!)

<<<<<<<<<<<<<<<<<<<<<
public IEnumerable<datetime> EachDay(DateTime from, DateTime thru) { for(var day = from.Date; day.Date <= thru.Date; day = day.AddDays(1)) yield return day; }

foreach (datetime day in EachDay(StartDate, EndDate)) // print it or whatever

<<<<<<<<<<<<<<<<<<<<

let femalesIn30s = members.filter { $0.gender == .female && $0.age >= 30 && $0.age < 40 }

let membersWithS = members.filter { $0.name.starts(with: "S") }
membersWithS.forEach { print($0.name) }
 
Sean
Susan


let sorted = numbers.sorted { $0 < $1 }
idem
let sorted = numbers.sorted(by: <)

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
Highlit collection cell

override func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {
    addToList.append(objectsArray[indexPath.row])
    let cell = collectionView.cellForItem(at: indexPath)
    cell?.layer.borderWidth = 200.0
    cell?.layer.borderColor = UIColor.init(red: 0/255, green: 0/255, blue: 0/255, alpha: 0.4).cgColor
}
<<<<<
//    override var isSelected: Bool {
//       didSet{
//           if self.isSelected {
//               UIView.animate(withDuration: 0.3) { // for animation effect
//                    self.backgroundColor = UIColor(red: 115/255, green: 190/255, blue: 170/255, alpha: 1.0)
//               }
//           }
//           else {
//               UIView.animate(withDuration: 0.3) { // for animation effect
//                    self.backgroundColor = UIColor(red: 60/255, green: 63/255, blue: 73/255, alpha: 1.0)
//               }
//           }
//       }
//   }
<<<<<<<
func collectionView(_ collectionView: UICollectionView, didHighlightItemAt indexPath: IndexPath) {
    if let cell = collectionView.cellForItem(at: indexPath) {
        cell.contentView.backgroundColor = #colorLiteral(red: 1, green: 0.4932718873, blue: 0.4739984274, alpha: 1)
    }
}

func collectionView(_ collectionView: UICollectionView, didUnhighlightItemAt indexPath: IndexPath) {
    if let cell = collectionView.cellForItem(at: indexPath) {
        cell.contentView.backgroundColor = nil
    }
}

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
let results = Dictionary(grouping: events, by: { $0["time"]! })
    .map { ($0.key, $0.value.map { $0["name"]! })}

let grouped = Dictionary(grouping: list, by: { $0 }).mapValues { items in items.count }

            let grouped = Dictionary(grouping: records, by: { $0.niko5M }).mapValues { items in items.count }
            let group = grouped.values.sorted()

for (key, value) in dict
{
    dict[key] = value.sorted(by: { $0.pri < $1.pri })
}


uid: 6zxxcvxJXcOqFxuBOfDcj74S6Yf2
location: ["Salin", "Production", "B"]
monthVsYear: true
personnal: false
date: 2022-04-08 22:17:48 +0000
location name : plant val: Salin
location name : workshop val: Production
location name : shift val: B
records dans requestRecordUser
[NikoMood.NikoRecord(_id: FirebaseFirestoreSwift.DocumentID<Swift.String>(value: Optional("3iinfwS06dulNzBe4hcr")), userID: "6zxxcvxJXcOqFxuBOfDcj74S6Yf2", firstname: "Serge", lastname: "Marinier", position: "Chef de poste", plant: "Salin", department:


